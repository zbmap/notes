                C practice

                summary

[*] 学习一门编程语言最好从使用的角度学习，虽然一个语言定义的东西非常琐碎非常多，
    但是从使用的角度看是另外一个视图，直接使用别人实践经验中总结出来的对语言的
    使用方法才是最快的学习方法，而不是对着语言参考手册学习，那是做编译器的人的最佳
    选择;

[*] 软件设计主要是考验程序员对代码或者问题的控制能力,即怎么组织你的代码能够简单
    而且能牢牢控制住它,即很容易读懂也很容易维护它,当感觉到很难读懂或者很难维护，说明
    需要重构了;

[*] 学习一们语言需要掌握name, object, bind; name就是一个对象的名字，
    其次一个bind是可以动态变化的，有初始化，中间动态变化等；比如java的引用赋值；

    程序设计的本质就是通过不同名字空间的去引用不同的对象，然后操作这些对象；

                        词法

[*] c词法分析中(token分析)的贪心法，即从左到右读入一个字符，如果该字符可能和后面
    的字符构成合法的符号，那么再读入下一个字符，检查已经读入的两个字符组成的
    字符串是否可能和下一个字符构成合法的字符，如果可能则继续读入，重复上述判断，
    直到读入的字符组成的字符串已不再可能和下一个字符组成一个有意义的token,则
    当前的这个字符串就是一个token；

[*] ‘a’和a以及"abc"一样都是token，只不过bind的东西不一样, "abc" bind 是一个
    数组；

[*] 对象都有数值，而且有类型，是因为很多应用上下文都需要考虑对象类型这个属性;

[*] C中字符编码未定义，即字符对应的整数值没有定义，字符在内存中存放的就是它对应
    的整数，所以，字符这个名称bind的就是一个整数，只不过它和整数的对应关系，
    即编码没有定义；

[*] C中 ‘a’ bind的对象是int类型，非char类型，c++中是char类型；注意char也是一种
    整数类型，只不过编码未定义而已；

[*] C中注释编译器处理方式是用一个空格替换，所以下面两个语句作用是一样的
    #define   LINE_NUMBER  (2)
    #define   LINE_NUMBER  /* line number
                             It can not = 0 */ （2*5）

[*] C中注释 (/**/    //)不能嵌套,大块的注释用 #if 0 #endif /* 从左向右扫描匹配
    第一个遇到的*/；

[*] C中所有运算符是单个token，包括符合运算符，不能用空白隔开，比如+=等等

[*] 编程字体要用等宽字体；

[*] 禁止使用8进制整数常量，即0开头的整数；

[*] 禁止修改字符串常量；

[*] C 语言的特点之一是“一词多用”，在不同的上下文中，C 语言的tocken 可能具有
    不同的含义 token重载非常多，所以需要根据上下文才能确定这个token的含义；

[*] 写代码时候，先把整个框架写好，然后在中间分层嵌入细节；
    if () {}
    do {} while ()
    void f() {}等等

    例如:
    while ((c = getchar () != EOF) {
        if (c == '\n') {
            ++nl ;
        }
    }
    上面代码少一个括号’)’，初学者无论是抄写书上的代码，还是写自己的代码，总是
    一行一行地用从左到右的方式写代码。他们的代码往往是这样演化形成的：
    while
    while ((
    while ((c = getchar ()
    while ((c = getchar () != EOF)
    这种方式完全是人类书写的自然方式，这样形成的代码漏掉一两个括号对任何人来说都
    是在所难免的。很可惜的是，这种方式虽然是人类书写时的自然方式，却不是写代码的
    良好方式。为了避免这种方式的弊端，高手们通常用另一种方式书写代码：
    while
    while () {}
    while (()) {}
    while (() != EOF) {}
    while ((c = getchar()) != EOF) {}
    也就是一旦需要写括号，首先把括号写全，然后再向其中补充内容。毫无疑问，
    这种写代码的“工序”更为合理，因为它可以避免括号不成对的问题。不仅括号应该这样
    写，其他一切成对的单词，如，{}、""、' '、[]、<>都应该按照这种方式书写。

    if (i == j);
        printf("%d==%d\n", i, j);
    这段代码，其原来的本意是希望在i 与j 相等时执行“printf("%d==%d\n",i,j);”，
    但由于错误地在“ if (i ==j ) ” 后面随手写了一个“;” ， 这使得后面的
    “printf("%d==%d\n",i,j);”成了与if 语句相互独立的一条语句，因此，程序无论
    在i和j 是否相等时都执行“printf("%d==%d\n",i,j);”这条语句一种良好的书写方式
    是先把if 语句的总体框架写完：
    if () {}
    然后再逐步地向其中添加内容。这样，代码的下一步将演化为：
    if (i == j) {}
    现在这个if 语句已经成为了一个完整的语句，即使现在编译，它也没有任何语法方面
    的问题。始终保持代码在形式上的正确性，这一点在编辑代码时非常重要。
    最后把这个语句补全：
    if (i == j) {
        printf("%d==%d\n",i,j);
    }
    这种方式完成的代码就不会有样本中误写多余的“;”之虞。

[*] 结构型的数组、多维的数组如果在定义时初始化，按照数组的矩阵结构分行书写。
    int aiNumbers[4][3] =  {
	    1, 1, 1,
	    2, 4, 8,
	    3, 9, 27,
	    4, 16, 64
    };
    原理:因为要定义的数组是一个4元素的数组,每个数组元素也是一个数组,所以这样写
    很容易看懂;

It is very important that any programmer be able to look at another's code and
quickly understand it. Maintaining a uniform style and following conventions
means that we can more easily use "pattern-matching" to infer what various
symbols are and what invariants are true about them. Creating common, required
idioms and patterns makes code much easier to understand. In some cases there
might be good arguments for changing certain style rules, but we nonetheless
keep things as they are in order to preserve consistency.

1. Coding style is all about readability and maintainability

    code就是让别人很容易明白你要让机器干什么；

2.  简洁、清晰
    不要过分追求技巧，否则会降低程序的可读性，所见即所得，一眼就能看懂准确含义的
    代码最好;

3.  一致
    一致性带来的将是更好的程序，如果程序中的格式很随意，例如对数组做循环，一会儿采用
    下标变量从下到上的方式，一会儿又用从上到下的方式；对字符串一会儿用strcpy做复制，
    一会儿又用for循环做复制等等，这些变化就会使人很难看清实际上到底是怎么回事，而
    如果相同计算的每次出现总是采用同样方式，任何变化就预示着是经过了深思熟虑，
    要求读程序的人注意。

    编辑代码时，花点时间看看项目中的其他代码并确定其风格，如果其他代码if 语
    句中使用空格，那么你也要使用。如果其中的注释用星号（*）围成一个盒子状，
    你也这样做：
    /**********************************
    * Some comments are here.
    * There may be many lines.
    **********************************/

    如果你工作在一个不是自己写的程序上，请注意保留程序原有的风格。当你需要做
    修改时，不要使用你自己的风格，即使你特别喜欢它，程序的一致性比你本人的习惯
    更重要，因为这将使随你之后的其他人生活得更容易些。


    > >Heh. Actually, Linux maintainers have generally very consciously _avoided_
    > >trying to "enforce" coding style issues.
    >
    > Really? "it's not going to be merged unless you turn all uint32_t into
    > u_int32_t" is a paraphrased variant of what I was told this month.

    I suspect different maintainers are hung up on different things, so yes,
    certain things are more likely to carry red flags, and it also depends on
    the patch.

    For example, if I get a patch for something that is a whole driver, I
    generally think that while I *prefer* to see it follow the kernel coding
    style, I also expect that the person who sends me the driver is the one
    who is going to maintain it in the future, and thus his personal coding
    style preferences will override any but the strongest objections.

    (So if somebody sends me a FSF-style "tabs are two characters, and
    functions must be longer than 300 lines" mess, I generally would prefer to
    not take it at all, but for some really obscure driver I might not care).

    In contrast, if a patch modifies code that somebody else really will end
    up touching in the future (maybe not "maintain", but maybe there is no
    single and obvious maintainer), it had better match the code around it.

    So to take your particular example: For me, "uint32_t" is certainly better
    than "u_int32_t" (and there's seven times as many of the former as the
    latter in the kernel), but for code _I_ would touch, I'd actually prefer
    the Linux internal "__u32"/"u32", which have no question about what their
    user-space visibility is (ie "__u32" is *always* ok in a header file that
    is visible to user space).

    But would I make it a huge issue? Not personally. So it will depend on the
    maintainer.

    (Personally, I think the "small functions, no deep levels of indentation,
    and tabs are 8 characters wide" are the most important part by far. But I
    do actually end up complaining about function naming etc too).

4.  学习经验用法
    和自然语言一样，程序设计语言也有许多惯用法，也就是那些经验丰富的程序员写
    常见代码片段的经验方式，在学习一个语言的过程中，一个中心问题就是逐渐熟悉它的
    经验用法，经验用法要么可以预防错误，要么能使错误更容易被发现，要么能使错误更容易
    被纠正。


        Indentation

[*] I think goto's are fine, and they are often more readable than large
    amounts of indentation;尽量少用缩进，缩进带来的后果就是代码不好理解；

[*] Tabs are 8 characters, and thus indentations are also 8 characters.
    Personally, I think the "small functions, no deep levels of indentation,
    and tabs are 8 characters wide" are the most important part by far.

[*] if you need more than 3 levels of indentation, you're screwed anyway,
    and should fix your program.

    and I think that's in many ways even more important than the 8-character
    tab, because deep indentation is unreadable even if you *can* fit it on a
    single line.(for_each macro is a example)

    In the kernel, we try to split functions up, and perhaps use inline
    functions etc, and really really avoid deep indentation.

[*] The preferred way to ease multiple indentation levels in a switch statement
    is to align the "switch" and its subordinate "case" labels in the same
    column instead of "double-indenting" the "case" labels.  E.g.:

    switch (suffix) {
    case 'G':
    case 'g':
        mem <<= 30;
        break;
    case 'M':
    case 'm':
        mem <<= 20;
        break;
    case 'K':
    case 'k':
        mem <<= 10;
        /* fall through */
    default:
        break;
    }


[*] Don't put multiple statements on a single line unless you have
    something to hide:
    if (condition) {do_this};
      do_something_everytime;

[*] Don't put multiple assignments on a single line either.

[*] coding style is super simple.  Avoid tricky expressions.

[*] Get a decent editor and don't leave whitespace at the end of lines.

[*] Doing things the common way is important
    An example of "common vs non-common" is this:

    if (0 <= x)
        do something..

    is something that crazy people do (sadly, one of the crazy people taught
    the git maintainer C programming, so now even sane people do it). It's
    crazy because it's uncommon, which means that most people have to think
    about it A LOT MORE than about

    if (x >= 0)
        do something..

    even though technically both are obviously EXACTLY THE SAME THING.


        Breaking long lines and strings

[*] 所有超过80列的应该是认为代码写的有问题的警告，解决方式是尽可能不超过80列，而不是简单
    断行；第一选择是不超过80列一行搞定，其次是超过80列不多一行搞定，实在没办法才采用折行；
    You should try to prevent writing lines longer than 80 characters rather than breaking them
    _splitting_ lines isn't the answer. Making code simpler is, but
    somehow the 80-column warning never causes that to happen - instead people
    just split.

[*] Line continuation: two indentations or embeded aligned, whatever is
    further indented.
    if (...
            ...) {
        do_sth();
    }

[*] never break user-visible strings such as printk messages, because that
    breaks the ability to grep for them.

[*] when nested inside parentheses, try to break lines at the shallower nesting
    levels, not the deeper ones.
    x = this_is_a(1, 2, very_long(line(3, 4, 5)));
    You might break it as:
    x = this_is_a(1, 2,
                very_long(line(3, 4, 5)));
    not:
    x = this_is_a(1, 2, very_long(line(3,
                                    4, 5)));
[*] 字符串常量禁止断行；

[*] 断行一元或者3元操作符和操作数同一行，2元操作符放在上一行的行末；


        Placing Braces and Spaces

[*] put the opening brace last on the line, and put the closing brace first,
    thusly:
    if (x is true) {
        we do y
    }
    This applies to all non-function statement blocks (if, switch, for, while, do).
    E.g.:
    switch (action) {
    case KOBJ_ADD:
        return "add";
    case KOBJ_REMOVE:
        return "remove";
    case KOBJ_CHANGE:
        return "change";
    default:
        return NULL;
    }

[*] there is one special case, namely functions: they have the opening brace
    at the beginning of the next line, thus:
    int function(int x)
    {
        body of function
    }

[*] the closing brace is empty on a line of its own, _except_ in the cases
    where it is followed by a continuation of the same statement,
    ie a "while" in a do-statement or an "else" in an if-statement, like this:
    do {
        body of do-loop
    } while (condition);
    and
    if (x == y) {
        ..
    } else if (x > y) {
        ...
    } else {
        ....
    }

[*] 控制结构的body都加{}即使是单条语句.
    if (condition) {
        action();
    }
    and
    if (condition) {
        do_this();
    } else {
        do_that();
    }

        Spaces

[*] use of spaces depends (mostly) on function-versus-keyword usage.
    Use a space after (most) keywords.  The notable exceptions are sizeof,
    typeof, alignof, and __attribute__, which look somewhat like functions
    (and are usually used with parentheses in Linux, although they are not
    required in the language, as in: "sizeof info" after
    "struct fileinfo info;" is declared).

[*] use a space after these keywords:
    if, switch, case, for, do, while

[*] not with sizeof, typeof, alignof, or __attribute__.  E.g.,
    s = sizeof(struct file);

[*] Do not add spaces around (inside) parenthesized expressions.
    This example is *bad*:
    s = sizeof( struct file );

[*] When declaring pointer data or a function that returns a pointer type, the
    preferred use of '*' is adjacent to the data name or function name and not
    adjacent to the type name.  Examples:
    char *linux_banner;
    unsigned long long memparse(char *ptr, char **retptr);
    char *match_strdup(substring_t *s);

[*] Use one space around (on each side of) most binary and ternary operators,
    such as any of these:
    =  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :

    but no space after unary operators:
    &  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined

[*] no space before the postfix increment & decrement unary operators:
    ++  --

[*] no space after the prefix increment & decrement unary operators:
    ++  --

[*] and no space around the '.' and "->" structure member operators.

[*] Do not leave trailing whitespace at the ends of lines.

[*] 函数名之后不要留空格。‘(’向后紧跟，‘)’、‘,’、‘;’向前紧跟，紧跟处不留空格。
    ‘,’之后要留空格。‘;’不是行结束符号时其后要留空格。
    例子中的 凵 代表空格。
    for凵(i凵=凵0;凵i凵<凵MAX_BSC_NUM;凵i++) {
        do_thing(a,凵b);
    }

[*] #define 宏时候中间使用单个空格隔开
    #define凵APP_DEFAULT_NIC_RX_RING_SIZE凵(4096)

[*] int i = 0; // Semicolons usually have no space before them.
    int x[2] = {0}; // Spaces inside braces for array initialization are
    for (i = 0; i < 5; i++) {
    switch (i) {
    case 1: // No space before colon in a switch case.
    ...

    x = 0; // Assignment operators always have spaces around them.
    x = -5; // No spaces separating unary operators and their
    ...

[*] 不同逻辑程序块之间要使用空行分隔


        Naming

[*] C is a Spartan language, and so should your naming be.
    C programmers do not use cute names like ThisVariableIsATemporaryCounter.
    A C programmer would call that variable "tmp", which is much easier to
    write, and not the least more difficult to understand.

[*] HOWEVER, while mixed-case names are frowned upon, descriptive names for
    global variables are a must.  To call a global function "foo" is a
    shooting offense.

[*] GLOBAL variables (to be used only if you _really_ need them) need to
    have descriptive names, as do global functions.  If you have a function
    that counts the number of active users, you should call that
    "count_active_users()" or similar, you should _not_ call it "cntusr()".

[*] LOCAL variable names should be short, and to the point.  If you have
    some random integer loop counter, it should probably be called "i".
    Calling it "loop_counter" is non-productive, if there is no chance of it
    being mis-understood.  Similarly, "tmp" can be just about any type of
    variable that is used to hold a temporary value.

[*] If you are afraid to mix up your local variable names, you have another
    problem, which is called the function-growth-hormone-imbalance syndrome.
    See chapter 6 (Functions).

[*] 考虑对象命名的原则就是从使用这个对象的使用场景描述；比如if （is_my_pkt（））
    考虑，肯定命名成is_my_pkt 代码读起来更容易理解；

[*] 标识符只使用26个英文字母，10个数字，及下划线的一个子集来组成，并严格禁止使用
    连续的下划线，下划线也不能出现在标识符头或结尾（预编译开关除外）这样做的目的
    是为了使程序易读。因为 variable_name 和 variable__name 很难区分，
    下划线符号‘_’若出现在标识符头或结尾，容易与不带下划线‘_’的标识符混淆

[*] 变量名一律小写，单词间以下划线相连；

[*] 程序中局部变量不要与全局变量重名

[*] 程序中不要出现仅靠大小写区分的相似的标识符

[*] 文件名要全部小写，可以包含下划线（_)按项目约定来。
    my_useful_class.c
    通常，尽量让文件名更加明确，http_server_logs.h 就比logs.h 要好，
    定义文件时文件名一般成对出现，如foo_bar.h 和foo_bar.c，对应FooBar模块。

[*] 对返回布尔类型值(真或者假)的函数命名，应该清楚地反映其返回值情况。
    if (chceck_octal)
    是不好的，因为它没有指明什么时候返回真，什么时候返回假。而：
    if (is_octal)
    就把事情说清楚了：如果参数是八进制数字则返回真，否则为假。


        类型
[*]
For various reasons, the kernel developers have a certain hatred for typedef that almost defies explanation. Their rationale is

typedef hides the real type of data structures.

Because the type is hidden, code is more prone to do bad things, such as pass a structure by value on the stack.

typedef is just being lazy.

Therefore, to avoid ridicule, avoid typedef.

Of course, there are a few good uses of typedefs: hiding an architecture-specific implementation of a variable or providing forward compatibility when a type may change. Decide carefully whether the typedef is truly needed or exists just to reduce the number of characters you need to type.

[*] Please don't use things like "vps_t". It's a _mistake_ to use typedef
    for structures and pointers. When you see a
    vps_t a;

    in the source, what does it mean?
    In contrast, if it says
    struct virtual_container *a;
    you can actually tell what "a" is.

[*] Lots of people think that typedefs "help readability". Not so. They are
    useful only for:

 (a) totally opaque objects (where the typedef is actively used to _hide_
     what the object is).

     Example: "pte_t" etc. opaque objects that you can only access using
     the proper accessor functions.

     NOTE! Opaqueness and "accessor functions" are not good in themselves.
     The reason we have them for things like pte_t etc. is that there
     really is absolutely _zero_ portably accessible information there.

 (b) Clear integer types, where the abstraction _helps_ avoid confusion
     whether it is "int" or "long".

     u8/u16/u32 are perfectly fine typedefs, although they fit into
     category (d) better than here.

     NOTE! Again - there needs to be a _reason_ for this. If something is
     "unsigned long", then there's no reason to do

    typedef unsigned long myflags_t;

     but if there is a clear reason for why it under certain circumstances
     might be an "unsigned int" and under other configurations might be
     "unsigned long", then by all means go ahead and use a typedef.

 (c) when you use sparse to literally create a _new_ type for
     type-checking.

 (d) New types which are identical to standard C99 types, in certain
     exceptional circumstances.

     Although it would only take a short amount of time for the eyes and
     brain to become accustomed to the standard types like 'uint32_t',
     some people object to their use anyway.

     Therefore, the Linux-specific 'u8/u16/u32/u64' types and their
     signed equivalents which are identical to standard types are
     permitted -- although they are not mandatory in new code of your
     own.

     When editing existing code which already uses one or the other set
     of types, you should conform to the existing choices in that code.

 (e) Types safe for use in userspace.

     In certain structures which are visible to userspace, we cannot
     require C99 types and cannot use the 'u32' form above. Thus, we
     use __u32 and similar types in all structures which are shared
     with userspace.

    Maybe there are other cases too, but the rule should basically be to NEVER
    EVER use a typedef unless you can clearly match one of those rules.

[*] In general, a pointer, or a struct that has elements that can reasonably
    be directly accessed should _never_ be a typedef.

[*] 尽可能少用类型抽象

[*] 如果使用类型定义则使用typedef 别使用宏,
   typedef  char *ntcs_t;
   const ntcs_t p = &data;
   p的类型是指向char类型的常量指针,而不是指向常量char的指针(#define);

[*] struct中的const field和普通const一样的语言；就是只能初始化，不能赋值；

[*] 有符号整数
    有符号整数溢出未定义
    除了定了宽度，同时对能表示的数值的最小范围进行了规定；
    有符号数字编码方式要么是2的补码、对1的补码或者带符号表示法，标准没有规定；
    但是正数的这三种编码方式都一样

[*] 无符号整数
    无符号数字编码方式唯一, 溢出定义为取模
    有些人，包括一些教科书作者，推荐使用无符号类型表示非负数，类型表明了数值取值
    形式, 但是，在C 语言中，这一优点被由其导致的bugs 所淹没。看看：
    unsigned int i;
    for (i = foo.Length() - 1; i >= 0; i--) ...
    上述代码永远不会终止！有时gcc 会发现该bug 并报警，但通常不会。
    类似的bug 还会出现在比较有符合变量和无符号变量时，
    主要是C 的类型提升机制会致使无符号类型的行为出乎你的意料。因此，
    使用断言声明变量为非负数，不要使用无符号型。只有当bit数组或者是必须要求某个
    宽度的范围内要存放一个很大的正整数的时候才使用无符号数，
    比如ipv4的ip头里面的ip字段，必须是32比特，因为要求是32比特，
    且需要表示的数值很大；即使这个时候如果用无符号数和有符号数混合进行运算，最好
    先手动转换成有符号数；
    尽可能少用无符号数： 代替方案：用更宽的有符号数表示，
    在需要unsigned longlong才能表示下或者宽度有要求，取值也有要求的情况下才使用
    无符号，比如ip报文中的ip地址只能用uint32_t;

[*] 整型（Integer Types）
    如果程序中需要不同大小的整型变量，
    可以使用<stdint.h>中的精确宽度（precise-width）的整型，如int16_t。
    <stdint.h>定义了int16_t、uint32_t、int64_t 等整型，
    在需要确定大小的整型时可以使用它们代替short、unsigned long long 等，
    使用标准类型如size_t 和ptrdiff_t。
    最常使用的是，对整数来说，通常不会用到太大，如循环计数等，可以使用普通的int。
    不要使用uint32_t 等无符号整型，除非你是在表示一个位组（bit pattern）而不是
    一个数值。

[*] enum的常量的值是int类型 ‘a’ bind的是int类型的值

[*] float类型用常数初始化后面都带f；

[*] c为什么不精确定义标准类型大小，由于c是一个汇编语言，所以尽可能挖掘具体机器
    的性能，所以把这些和机器密切相关的都放给实现自己去定义；

[*] 整数包括很多类型，不是同一个类型；

[*] bitfield 和register类型对象也不能用&运算符和->；

[*] &数组名和指向第一个数组元素类型的指针不同，前者是数组类型的指针，后面是
    元素类型指针；

[*] 数组只有一维数组，但是可以通过数组的元素是数组的方式模拟出多维数组；

[*] 数组名称除了在sizeof和&运算符以及作为初始化数组的字符数组的时候代表的是数组
    本身之外，其它的场合都是转换成指向第一个元素的指针，
    例如作为函数的参数声明为数组类型，自动转换成元素类型的指针类型；

[*] 常量指的是值不会改变的量，可以是左值也可以是右值；常量需要注意时间问题，
    即什么时候开始创建了她代表的这个值，例如运行前（翻译阶段），还是运行时候，
    即使是运行时候也有具体什么时候运行时候创建的；

[*] 类型限定符，const volatile 会改变类型；

[*] C字符串 不包括‘\0’，它只是作为一个字符串结束的标示字符，一个结束tag存在，

[*] 类型刻画的是一组界面约束，例如内存表示，内存对齐，能够取值，能够进行的操作；

[*] char 用于表示字符或者字符数组的场景,小整数通过int8_t或者uint8_t使用，

[*] 记住sizeof(void *) != sizeof(int)，如果需要一个指针大小的整数要使用intptr_t。

[*] 整数用0，实数用0.0，指针用NULL，字符用'\0'。

[*] 结构本质上就是一种built-in数据结构

[*] 使用指针考虑方式：指针也就是一个类型，和int一样，有内存分配和内存表示方式，
    以及内存对齐的要求，也有某些操作，例如* &等操作而已；比如下面的char **token，
    token表示的是一块内存，有分配，有表示，*token标示的是char* 的内存对象；
    int rte_strsplit(char *string, int stringlen,
                char **tokens, int maxtokens, char delim)
[*] 关注定义的是一个什么类型，然后有什么运算，运算的结果又是什么类型的 值是多少

[*] int i;
    假如int 类型的变量占据的内存单元为2 个Byte，并且i 所占据的两个内
    存单元的编号分别为十六进制的ABCD 和ABCE。那么&i 的值则为ABCD。然而&i 这个
    指针所指向的对象却并非是编号为ABCD 的这个内存单元，事实上&i 这个指针指向的
    是编号为ABCD 和ABCE这两个Byte——指向变量i 这个数据对象。然而受到“指针就是
    地址”误导的初学者却很难体会到这点。因为仅仅单有地址这个概念而缺乏指针数据
    类型这个概念，是不可能理解“指向”的含义的。

[*] 匿名结构体和联合的使用：
    Anonymous union inside structures are very useful in practice.
    Consider that you want to implement a discriminated sum type
    (or tagged union), an aggregate with a boolean and either a float or a
    char* (i.e. a string), depending upon the boolean flag.
    With C11 you should be able to code

    typedef struct {
        bool is_float;
        union {
            float f;
            char* s;
        };
    } mychoice_t;

    double as_float(mychoice_t* ch)
    {
        if (ch->is_float)
            return ch->f;
        else
            return atof(ch->s);
    }
    With C99, you'll have to name the union, and code ch->u.f and ch->u.s which is
    less readable and more verbose.
    即匿名联合使用在具名struct，匿名struct使用在匿名union里面；

[*] offsetof 不适用于bitfields

[*] 显式指定数组的边界,即使根据数组初始化列表隐式指定了边界;字符数组使用
    字符串常量初始化除外原因:提供了长度冗余检查功能;

[*] p[i] 表达式的含义是*((p) + (i)),所以可以这样考虑数组和指针的关系;

[*] 字符数组或者字符串是通过strlen等等来遍历，普通数组是按照定义的时候下表来遍历
    不一样，所以非字符串直接初始化的数组都需要严格指定边界；


        Functions

[*] Functions should be short and sweet, and do just one thing.  They should
    fit on one or two screenfuls of text (the ISO/ANSI screen size is 80x24,
    as we all know), and do one thing and do that well.

[*] The maximum length of a function is inversely proportional to the
    complexity and indentation level of that function.  So, if you have a
    conceptually simple function that is just one long (but simple)
    case-statement, where you have to do lots of small things for a lot of
    different cases, it's OK to have a longer function.

[*] However, if you have a complex function, and you suspect that a
    less-than-gifted first-year high-school student might not even
    understand what the function is all about, you should adhere to the
    maximum limits all the more closely.  Use helper functions with
    descriptive names (you can ask the compiler to in-line them if you think
    it's performance-critical, and it will probably do a better job of it
    than you would have done).

[*] Another measure of the function is the number of local variables.  They
    shouldn't exceed 5-10, or you're doing something wrong.  Re-think the
    function, and split it into smaller pieces.  A human brain can
    generally easily keep track of about 7 different things, anything more
    and it gets confused.  You know you're brilliant, but maybe you'd like
    to understand what you did 2 weeks from now.

[*] In source files, separate functions with one blank line.  If the function is
    exported, the EXPORT* macro for it should follow immediately after the
    closing function brace line.  E.g.:

    int system_is_up(void)
    {
        return system_state == SYSTEM_RUNNING;
    }
    EXPORT_SYMBOL(system_is_up);

[*] In function prototypes, include parameter names with their data types.
    Although this is not required by the C language, it is preferred in Linux
    because it is a simple way to add valuable information for the reader.
[] static inline not inline static, storage pre inline
[*] 函数声明与定义返回类型和函数名在同一行，参数也尽可能放在同一行。函数看上去
    这样：
    int rte_eth_dev_set_vlan_pvid(uint8_t port_id, uint16_t pvid, int on)
    {
    ...
    }
    如果同一行文本较多，容不下所有参数：
    int rte_eth_dev_set_vlan_pvid(uint8_t port_id,
            uint16_t pvid, int on)
    {
        ...
    }
    甚至连第一个参数都放不下：这种一般都有问题，需要重新命名等；
    int rte_eth_dev_set_vlan_pvid(
            uint8_t port_id,
            uint16_t pvid,
            int on)
    {
        ...
    }

[*] 返回值总是和函数名在同一行；

[*] 左圆括号（open parenthesis）总是和函数名在同一行；

[*] 函数名和左圆括号间没有空格；

[*] 圆括号与参数间没有空格；

[*] 左大括号（open curly brace）总在新一行；

[*] 右大括号（close curly brace）总是单独位于函数最后一行；

[*] 函数调用尽量放在同一行，左圆括号后和右圆括号前不要留空格。
    函数调用遵循如下形式：
    int ret = dosomething(argument1, argument2, argument3);
    如果同一行放不下，可断为多行，通用做法是断行尽可能靠右，至少缩进2个tab就ok；：
    int ret = dosomething(averyveryveryverylongargument1,
            argum ent2, argument3);

    如果函数名太长，以至于超过行最大长度，可以将所有参数独立成行：
    if (...) {
        ...
        if (...) {
            do_something_that_require_a_long_function_name(
                    very_long_argument1, argument2,
                    argument3, argument4);
        }
    }

[*] never use an array notation or fucntion notation as a function parameter

[*] 函数词法定义中除了定了很多语句之外，还可以定义static变量，这个并不是语句，
    而是采用了函数也引入了一个作用域的机制；

[*] 在函数原型中必须包含函数名和它们的参数数据类型和参数名称，而且函数声明和实现
    处的所有形参名称必须保持一致；因为这样可以很简单的给读者提供更多的有价值的信息;
    反例
    static void check_ports_link_status(uint8_t, uint32_t);
    正例
    static void check_ports_link_status(uint8_t port_num, uint32_t port_mask);

[*] C 函数对象定义只有全局的没有局部的;

[*] c函数对象是const的，不能赋值，即函数名字不能出现在赋值运算符左侧;

[*] C函数类型包括声明和定义，和普通变量一样，函数也是种类型，只不过函数的初始化
    并不是用赋值运算符而已，采用{};

[*] c函数包括extern和static函数，缺省是extern函数，所以extern函数就不要写extern;
    extern函数的声明必须放在.h文件,static函数的声明放在.c文件，static函数不需要声明
    只要在.c文件中定义就可以，所有使用extern的源文件都通过include这个.h文件进行使用;

[*] c函数调用参数都是传值语义，函数参数传值是赋值的语义，传参数的过程是把实参
    通过赋值转换到形参的类型，然后构造内存布局，然后调用的时候就可以正确按照形参
    引用访问对应的内存布局，这个布局是编译器定好的调用者和被调用者之间的约定;
    可变参数函...参数由于没有指定类型，调用的时候采用缺省参数提升规则构造内存
    布局，解析也是交给被调用函数进行解析；编译器能保证的就是按照缺省参数提升去
    构造内存布局；

[*] 变参函数是调用时知道类型，即编译器只有看到这个函数的每个具体的使用的时候，
    才知道传入的是几个参数，然后每个参数的类型是什么，然后就知道每个具体调用对应i
    的内存布局；
    变参数不要太特殊考虑，只是一种弱的约定, 有原型使用者和定义者有明确约定好的
    协定, 没有的话,编译器根据具体每个具体使用的参数生成对应的内存布局；

[*] 尽量不要使用类型和数目不确定的参数。
    说明：对于参数个数可变的函数调用，编译器不作类型检查和参数检查。
    这种风格的函数在编译时丧失了严格的类型安全检查。

[*] 函数参数不能是(...)，即至少要有一个参数是固定的；
    If a function that accepts a variable number of arguments is defined without
    a parameter type list that ends with the ellipsis notation, the behavior is
    undefined

[*] f()是可变参数个数的函数声明,如果函数没有参数，则用void填充。
    正例：
    static void app_init_mbuf(void);
    void app_init(void);
    反例：
    static void app_init_mbuf();

[*] 函数形参和定义在函数体最开始定义的标识符具有相同的作用域，所以形参不能在函数
    体内重新定义;

[*] 定义函数时，参数顺序为：输入参数在前，既是输入又是输出的参数中间然后是
    输出参数; 当结构变量作为参数时，应传送结构的指针而不传送整个结构体，
    并且不得修改结构中的元素，用作输出时除外。

[*] c函数返回类型不能是数组类型和函数类型,可以通过返回它俩的指针来间接实现;

[*] 如果函数返回值类型T不是void,则return 之后的表达式必须能满足通过赋值转换成T
    类型，函数返回的语义就是求return表达式的值，然后通过赋值转换到返回类型的值;

[*] 函数返回的语义是赋值的语义，即把return表达之的值赋值给一个返回值类型的
    临时对象；

[*] 函数的返回值不是左值;
    f() = x; /*无效*/
    *f() = x; /*有效*/
    f().a = x; /*无效*/

[*] 不要省略返回值的类型，如果函数没有返回值，那么应声明为void类型;

[*] 返回void函数末尾不要加return；

[*] 函数返回值return 表达式中不要使用圆括号。
    return x;
    not return (x);

[*] C90 标准规定main()函数只有两种可能的形式：
    int main(void) { /* ... */ }
    或：
    int main(int argc, char argv[]) { / ... */ }
    后者的第二个参数也可以写作char **argv。也就是说，这两种形式以外的各种
    main()函数都不符合C90 标准。

    C99 在此基础上做了一个补充，规定main()函数也可以是实现所定义
    的其他方式。依照这条规定，这种void main()最多只能算是某种编译器的一种“方言”而已
    ，并且必须是在编译器遵守C99 标准这个前提下。
    main()函数的特殊之处在于它是程序执行的起点。尽管如此，从其他函数调用
    main()函数是允许的，甚至从main()递归调用main()也不受限制。C++程序对程序的
    启动有着更加严格的控制，不允许对main()进行递归调用

[*] 函数名称要和返回值放在一行的依据：
    grep -i '^[a-z_ ]*(' *.c

    >> Proposed conversion:
    >>
    >> int foo(void)
    >> {
    >>      /* body here */
    >> }
    >
    >Sometimes it is nice to be able to see function names with a
    >
    >   grep '^[a-zA-Z].*(' *.c
    >
    >which is why I've always preferred
    >
    >int
    >foo(void)
    >{
    >   /* body here */
    >}

    That makes no sense.

    Do you write your normal variable definitions like

        int
        a,b,c;

    too? No you don't, because that would be totally idiotic.

    A function declaration is no different. The type of the function is very
    important to the function itself (along with the arguments), and I
    personally want to see _all_ of it when I grep for functions.

    You should just do

        grep -i '^[a-z_ ]*(' *.c

    and you'll get a nice function declaration with the standard kernel
    coding style.

    And I personally don't normally do "grep for random function
    declarations", that just sounds like a contrived example.  I grep for
    specific function names to find usage, and then it's _doubly_ important
    to see that the return (and argument) types match and make sense.

    So I definitely prefer all the arguments on the same line too, even if
    that makes the line be closer to 100 chars than 80.  The zlib K&R->ANSI
    conversion was a special case, and I'd be happy if somebody were to have
    the energy to convert it all the way (which implies moving comments
    around etc).


[*] >   if (tick_init_highres()) {
    >       local_irq_restore(flags);
    > -     return;
    > +     return 0;

    Ohh-oh! This is clearly a failure scenario! And indeed,
    "tick_init_highres()" will do the "negative on failure, zero on success"
    thing.

    BUT! That means that you're testing the return value WRONG!

    A function that returns a negative error value should be tested with

        if (tick_init_highres() < 0) {
            local_irq_restore(flags);
            return 0;
        }


        Centralized exiting of functions

[*] The goto statement comes in handy when a function exits from multiple
    locations and some common work such as cleanup has to be done.  If there is
    no cleanup needed then just return directly.

[*] Choose label names which say what the goto does or why the goto exists.  An
    example of a good name could be "out_buffer:" if the goto frees "buffer".
    Avoid using GW-BASIC names like "err1:" and "err2:".  Also don't name them
    after the goto location like "err_kmalloc_failed:"

    The rationale for using gotos is:

    - unconditional statements are easier to understand and follow
    - nesting is reduced
    - errors by not updating individual exit points when making
        modifications are prevented
    - saves the compiler work to optimize redundant code away ;)

        int fun(int a)
        {
            int result = 0;
            char *buffer;

            buffer = kmalloc(SIZE, GFP_KERNEL);
            if (buffer == NULL) {
                return -ENOMEM;
            }

            if (condition1) {
                while (loop1) {
                    ...
                }
                result = 1;
                goto out_buffer;
            }
            ...
        out_buffer:
            kfree(buffer);
            return result;
        }

[*] A common type of bug to be aware of it "one err bugs" which look like this:
        err:
            kfree(foo->bar);
            kfree(foo);
            return ret;

    The bug in this code is that on some exit paths "foo" is NULL.  Normally
    the fix for this is to split it up into two error labels "err_bar:" and
    "err_foo:".

[*] goto balbel must not indent


        Commenting

[*] Comments are good, but there is also a danger of over-commenting.  NEVER
    try to explain HOW your code works in a comment: it's much better to
    write the code so that the _working_ is obvious, and it's a waste of
    time to explain badly written code.

[*] Generally, you want your comments to tell WHAT your code does, not HOW.
    Also, try to avoid putting comments inside a function body: if the
    function is so complex that you need to separately comment parts of it,
    you should probably go back to chapter 6 for a while.  You can make
    small comments to note or warn about something particularly clever (or
    ugly), but try to avoid excess.  Instead, put the comments at the head
    of the function, telling people what it does, and possibly WHY it does
    it.


[*] comments is the C89 "/* ... */" style.
    Don't use C99-style "// ..." comments.

    The preferred style for long (multi-line) comments is:

    /*
     * This is the preferred style for multi-line
     * comments in the Linux kernel source code.
     * Please use it consistently.
     *
     * Description:  A column of asterisks on the left side,
     * with beginning and ending almost-blank lines.
     */


[*] It's also important to comment data, whether they are basic types or derived
    types.  To this end, use just one data declaration per line (no commas for
    multiple data declarations).  This leaves you room for a small comment on each
    item, explaining its use.

[*] 注释符与注释内容之间要用一个空格进行分隔。
    /* 注释内容 */


        Data structures

[*] Data structures that have visibility outside the single-threaded
    environment they are created and destroyed in should always have
    reference counts.  In the kernel, garbage collection doesn't exist (and
    outside the kernel garbage collection is slow and inefficient), which
    means that you absolutely _have_ to reference count all your uses.

[*] Reference counting means that you can avoid locking, and allows multiple
    users to have access to the data structure in parallel - and not having
    to worry about the structure suddenly going away from under them just
    because they slept or did something else for a while.

[*] Note that locking is _not_ a replacement for reference counting.
    Locking is used to keep data structures coherent, while reference
    counting is a memory management technique.  Usually both are needed, and
    they are not to be confused with each other.

[*] Many data structures can indeed have two levels of reference counting,
    when there are users of different "classes".  The subclass count counts
    the number of subclass users, and decrements the global count just once
    when the subclass count goes to zero.

    Examples of this kind of "multi-level-reference-counting" can be found in
    memory management ("struct mm_struct": mm_users and mm_count), and in
    filesystem code ("struct super_block": s_count and s_active).

[*] Remember: if another thread can find your data structure, and you don't
    have a reference count on it, you almost certainly have a bug.


        Macros, Enums and RTL

[*] Names of macros defining constants and labels in enums are capitalized.

    #define CONSTANT (0x12345)

[*] Enums are preferred when defining several related constants.

[*] Generally, inline functions are preferable to macros resembling functions.

[*] Macros with multiple statements should be enclosed in a do - while block:

    #define macrofun(a, b, c)           \
        do {                    \
            if (a == 5) {        \
                do_this(b, c);      \
            }  \
        } while (0)

[*] Things to avoid when using macros:

    1) macros that affect control flow:

    #define FOO(x)                  \
        do {                    \
            if (blah(x) < 0) {        \
                return -EBUGGERED;  \
            } \
        } while(0)

    is a _very_ bad idea.  It looks like a function call but exits the "calling"
    function; don't break the internal parsers of those who will read the code.

    2) macros that depend on having a local variable with a magic name:

    #define FOO(val) bar(index, val)

    might look like a good thing, but it's confusing as hell when one reads the
    code and it's prone to breakage from seemingly innocent changes.

    3) macros with arguments that are used as l-values: FOO(x) = y; will
        bite you if somebody e.g. turns FOO into an inline function.
    4)模拟函数的参数宏的参数禁止直接在宏体内部进行赋值，即尽可能把模拟成函数的参数宏尽可能
    和函数一样使用，即使修改，也定义成传指针的方式；

    5) forgetting about precedence: macros defining constants using expressions
        must enclose the expression in parentheses. Beware of similar issues with
        macros using parameters.

    #define CONSTANT (0x4000)
    #define CONSTEXP (CONSTANT | 3)

    5) namespace collisions when defining local variables in macros resembling
    functions:

    #define FOO(x)              \
    ({                  \
        typeof(x) ret;          \
        ret = calc_ret(x);      \
        (ret);              \
    })

    ret is a common name for a local variable - __foo_ret is less likely
    to collide with an existing variable.

[*] 如果enum中两个常量之间有关系一定要体现出来;假设下面例子中的B总是比A大2
    enum {A = 1, B = 3};应该改成enum {A = 1, B = A + 2,};

[*] 预处理指令不要缩进，从行首开始。即使预处理指令位于缩进代码块中，
    指令也应从行首开始。
    // Good - directives at beginning of line
    if (lopsided_score) {
#if DISASTER_PENDING // Correct -- Starts at beginning of line
        DropEverything();
#endif
        BackToNormal();
    }

    // Bad - indented directives
    if (lopsided_score) {
        #if DISASTER_PENDING // Wrong! The "#if" should be at beginning of line
        DropEverything();
        #endif // Wrong! Do not indent "#endif"
        BackToNormal();
    }

#ifdef CONFIG_USB_HIDDEV

#define HIDDEV_FUNCT extern void hiddev_hid_event (struct hid_device *, unsigned int usage,int value);

#else

#define HIDDEV_FUNCT ;

#endif

[*] 宏的实参如果是一个带有副效应的表达式，在实际编程中是一种绝对的禁忌
    #define ISUPPER(c) ((c)>='A' && (c)<='Z')
    这段宏的意图是判断c 是否是大写字母。但是在下面代码中这个宏会发生问题：
    if (ISUPPER (getchar())) {
        printf("输入的是大写字母\n");
    } else {
        printf("输入的是非大写字母\n");
    }
    这段代码的本意是输入一个字符，判断输入的字符是否是大写字母。然而，
    由于ISUPPER ( getchar() ) 在预处理阶段会被展开为
    ((getchar())>='A' && (getchar())<='Z')，输入一个字符变成了两次读取字符，
    完全违背了最初的意图。由于这些原因，宏的实参如果是一个带有副效应的表达式，
    在实际编程中是一种绝对的禁忌。不仅自己定义的宏如此，
    使用putc()等实际上是用宏实现的“库函数”时也要特别注意这一点。

[*] #define maxint(a,b) \
       ({int _a = (a), _b = (b); _a > _b ? _a : _b; })
    gcc的表达式语句完全可以替换掉的do {}while（0）宏定义；

[*] 宏定义要不要加括号什么的，完全是由使用宏的使用角度说的,即从
    如何使用这个参数决定的，如果允许参数是表达式，则宏定义里面必须加括号；
    比如字符串拼接，就不可能是表达式，也不允许加括号，所以就没必要；

[*] 参数宏body尽可能每个参数都加上(),整个body尽可能加上();除了##等有些应用场景是
    不能加的;
    #define CUBE(a, b) ((a) * (b))

[*] 无参数宏就是不管3721直接把body 进行文本拷贝;带参数宏是先词法分析body,然后
    把对应的token用使用使用宏的实际参数替换,然后再拷贝过去;

[*] ##如果左右两个token有是宏的话,不进行展开,所以定义的时候最好采用中间再加一个
    宏的方式,可以先展开这个##中的宏,使得##两边直接面对的的都不是宏;

[*] #define empty_statement do { } while (0)

    instead of

    #define empty_statement /* empty */


        The inline disease

    There appears to be a common misperception that gcc has a magic "make me
    faster" speedup option called "inline". While the use of inlines can be
    appropriate (for example as a means of replacing macros, see Chapter 12), it
    very often is not. Abundant use of the inline keyword leads to a much bigger
    kernel, which in turn slows the system as a whole down, due to a bigger
    icache footprint for the CPU and simply because there is less memory
    available for the pagecache. Just think about it; a pagecache miss causes a
    disk seek, which easily takes 5 milliseconds. There are a LOT of cpu cycles
    that can go into these 5 milliseconds.

    A reasonable rule of thumb is to not put inline at functions that have more
    than 3 lines of code in them. An exception to this rule are the cases where
    a parameter is known to be a compiletime constant, and as a result of this
    constantness you *know* the compiler will be able to optimize most of your
    function away at compile time. For a good example of this later case, see
    the kmalloc() inline function.

    Often people argue that adding inline to functions that are static and used
    only once is always a win since there is no space tradeoff. While this is
    technically correct, gcc is capable of inlining these automatically without
    help, and the maintenance issue of removing the inline when a second user
    appears outweighs the potential value of the hint that tells gcc to do
    something it would have done anyway.


        Function return values and names

[*] Functions can return values of many different kinds, and one of the
    most common is a value indicating whether the function succeeded or
    failed.  Such a value can be represented as an error-code integer
    (-Exxx = failure, 0 = success) or a "succeeded" boolean (0 = failure,
    non-zero = success).

    If the name of a function is an action or an imperative command,
    the function should return an error-code integer.  If the name
    is a predicate, the function should return a "succeeded" boolean.

For example, "add work" is a command, and the add_work() function returns 0
for success or -EBUSY for failure.  In the same way, "PCI device present" is
a predicate, and the pci_dev_present() function returns 1 if it succeeds in
finding a matching device or 0 if it doesn't.

All EXPORTed functions must respect this convention, and so should all
public functions.  Private (static) functions need not, but it is
recommended that they do.

Functions whose return value is the actual result of a computation, rather
than an indication of whether the computation succeeded, are not subject to
this rule.  Generally they indicate failure by returning some out-of-range
result.  Typical examples would be functions that return pointers; they use
NULL or the ERR_PTR mechanism to report failure.

[*]makes the new user_mode() return 0 or 1 (same as x86_64)

    I _really_ prefer

    x != 0

    over

    !!x

    since double negation is not only a bad habit in natural languages, it's a
    bad habit in computer languages too, for exactly the same reason. It's
    confusing.

    Ask a hundred random C programmers what "!!x" means, versus what "x != 0"
    means, and time their replies.

    I will bet you $5 USD that even if they all give the right answer (and I
    suspect you'll get a few wrong answers in there too for the !! case),
    they'll take a _lot_ longer answering the "!!x" version than they will the
    "x != 0" question.

    And guess what? That means that the "!!x" version is worse. It means that
    people don't "see" what it means - they have to think about it. And you
    shouldn't have to think about something like that, you should write it in
    the obvious way in the first place.

[*] ALWAYS use "negative means error"


        Conditional Compilation

[*] Wherever possible, don't use preprocessor conditionals (#if, #ifdef) in .c
    files; doing so makes code harder to read and logic harder to follow.
    Instead, use such conditionals in a header file defining functions for use
    in those .c files, providing no-op stub versions in the #else case,
    and then call those functions unconditionally from .c files.
    The compiler will avoid generating any code for the stub calls, producing
    identical results, but the logic will remain easy to follow.

[*] Prefer to compile out entire functions, rather than portions of functions or
    portions of expressions.  Rather than putting an ifdef in an expression,
    factor out part or all of the expression into a separate helper function
    and apply the conditional to that function.

[*] If you have a function or variable which may potentially go unused in a
    particular configuration, and the compiler would warn about its definition
    going unused, mark the definition as __maybe_unused rather than wrapping it
    in a preprocessor conditional.  (However, if a function or variable *always* goes
    unused, delete it.)

[*] At the end of any non-trivial #if or #ifdef block (more than a few lines),
    place a comment after the #endif on the same line, noting the conditional
    expression used.  For instance:


        head file

[*] 禁止复用和标准文件头文件一样的文件名;

[*] Never #include a .c file for any reason!

[*] 所有头文件都应该使用#define 防止头文件被重复包含，命名格式应当是：
    <PROJECT>_<PATH>_<FILE>_H_，为保证唯一性，头文件的命名应基于其所在项目
    源代码树的全路径。例如，项目foo 中的头文件foo/src/bar/baz.h 按如下方式保护：
    #ifndef FOO_BAR_BAZ_H_
    #define FOO_BAR_BAZ_H_
    ...
    #endif

[*] 使用前置声明（forward declarations, python import a name from a module）
    尽量减少.h 文件中#include 的数量。
    当一个头文件被包含的同时也引入了一项新的依赖（dependency），只要该头文件被
    修改，代码就要重新编译。如果你的头文件包含了其他头文件，这些头文件的任何改变
    也将导致那些包含了你的头文件的代码重新编译。因此，我们宁可尽量少包含头文件，
    尤其是那些包含在其他头文件中的。使用前置声明可以显著减少需要包含的头文件
    数量。
        举例说明：头文件中用到struct File，但不需要访问File 的声明，
        则头文件中只需前置声明struct File;无需#include
        "file/base/file.h"。
    在头文件如何做到使用struct Foo 而无需访问struct的定义？将数据成员类型声明为
    Foo *。
    struct X; /* incomplete ("forward") declaration */
    struct Thing {
    int i;
    struct X* x_ptr;
    };

[*] 头文件中包含头文件次序如
    （原理，从一般到特殊，即从最不可能变化的头文件到最可能变化的头文件）：
    C 库
    其他库的.h、
    项目内的.h。

    #include <sys/types.h>
    #include <unistd.h>
    #include "base/basictypes.h"
    #include "base/commandlineflags.h"

[*] 项目内头文件应按照项目源代码目录树结构排列，并且避免使用UNIX 文件路径.
（当前目录）和..（父目录）。例如，google-awesome-project/src/base/logging.h
    应像这样被包含：
   #include "base/logging.h"

[*] .c文件中头文件包含顺序：自己模块对应的头文件，c系统文件、其他库文件、
    本项目内其他头文件；
   例如foo.c 中包含头文件的次序如下
   （原理，从一般到特殊，即从最不可能变化的头文件到最可能变化的头文件，
   同时把自己对应的头文件放在第一个可以检查自己的头文件是否依赖别的头文件）：
    dir2/foo2.h（优先位置）
    C 系统文件
    其他库头文件
    本项目内头文件
    举例来说，google-awesome-project/src/foo/internal/fooserver.c 的包含次序如下：
    #include "foo/public/fooserver.h" // 优先位置
    #include <sys/types.h>
    #include <unistd.h>
    #include "base/basictypes.h"
    #include "base/commandlineflags.h"
   #include "foo/public/bar.h"

[*] include a.h 像python import a 模块;


                    声明
[*] 不要对全局声明的顺序做任何的假设;即静态局部或者全局变量都初始化为常量,
    不要和其他全局变量进行初始化顺序的依赖;

[*] 一行只声明一个变量,
    Declaring multiple variables in a single declaration could cause confusion
    about the types of variables and their initial values. In particular,
    do not declare any of the following in a single declaration:
        * Variables of different types
        * A mixture of initialized and uninitialized variables；

[*] 声明引入一个和一个东西bind的自定义token，即标识符；

[*] c作用域都是标识符作用域没有名字空间的作用域；

[*] 不要依赖于静态变量的初始化值，要明确写出它的值，即使使用的是缺省值；

[*] 不要在语句块内声明局部变量,所有变量都是函数级别的，不需要初始化的局部变量
    就不要初始化；

[*] 局部静态变量和全局变量的唯一区别就是作用域,他们都是在main之前就初始化好了;

[*] sizeof 中struct的定义的声明的结构体都用匿名的，省的迷糊别人以为作用域只是在
    他们的范围内；其实是和声明的的是同一个名字空间

[*] c声明方式：通过使用方式进行声明；类型 + 生成基本类型的表达式；表达式求值的
    结果应该是前面的类型，就能推导出name的类型了；由于是表达式所以可以加括号，
    比如 int a；int (a)一样，只要把结尾的分号以及变量名称去掉就是类型，进行类型
    转换时，直接加上小括号就ok

[*] 数组的声明大小没必要指定,但是类型一定要清楚,比如二维数组,
    第一纬度没必要,但是第二纬度是必须的;extern int a[]; extern int b[][10],

[*] 最佳实践是不要声明数组了,直接声明对应首个元素的指针最好了;省的误导;
    和不要在函数参数里面使用数组一样,不然使用方可能真的觉得是数组,
    然后采用sizeof这样的运算符;

[*] union初始化默认只能初始化第一个元素，如果想初始化其他元素，则使用指定初始化
    的形式；
[*] 结构初始化：
static const struct file_operations changer_fops = {
        .owner          = THIS_MODULE,
        .open           = ch_open,
        .release        = ch_release,
        .unlocked_ioctl = ch_ioctl,
#ifdef CONFIG_COMPAT
        .compat_ioctl   = ch_ioctl_compat,
#endif
        .llseek         = noop_llseek,
};

[*]数组初始化：
const char *const btrfs_feature_set_names[3] = {
        [FEAT_COMPAT]    = "compat",
        [FEAT_COMPAT_RO] = "compat_ro",
        [FEAT_INCOMPAT]  = "incompat",
};

                    表示和转换

[*] 内存表示关注的是占用多大的内存，这些内存是怎么布局的，然后内部是怎么
    比特编码的，以及内存怎么对齐的；比如struct中间和尾部都可能有pad空间；

[*] 类型转换是指某个类型的值转换为另外一个类型的值，
    即一个类型的内存表示转换为另外一个类型的内存表示，分为自动转换和强制转换(t)；

[*] 必须以bit级别学习c语言，即c就是一个高级汇编语言，
    按照汇编语言去学习c（某个类型对象的内存表示，占用多大空间，有效空间有哪些，
    怎么比特编码的，比特顺序是什么，然后内存是如何对齐的）

[*] 字节序本质上就是数据值得内存表示，本质上是比特序，只不过下层控制器都是至少
    一个字节进行处理的，所以简化为字节序；

[*] 对象指针和函数指针不一样；

[*] 指针转换成无符号数的规则是把指针的内存表示直接用无符号数进行解析，
    而整数浮点数转换关注的是值，不是内存表示

[*] 允许的类型转换，即可以通过()进行的转换


                表达式
[*] 不要再sizeof表达式中使用带有副作用的表达式;误导别人, sizeof() 只有可变
    长度的数组的时候才对表达式进行求值,其余都不计算表达式的值;

[*] v +=e 含义是求值v，求值e，然后求他们两的和，然后赋值给v，
    并不等价于v = v + e表达式，后面可能有副作用，需要两次对v求值；

[*] NULL一般定义成(void *)0， 虽然可以定义成整数0，但是这样的好处是，(void *)0是
    个指针类型，整数0，含义就多了，他可以根据上下文，自动转换为一个字符‘\0’，
    0.0，无效指针等；所以最好明确采用（void *）0表示就是指针，这样用在if语句等
    地方，编译器可以进行检查是整数还是指针，如果判等的是一个整数，编译器就会
    报错；其他整数和指针编译器会自动判断的，只有0特殊；

[*] +2 = 0 + 2  –2 = 0 – a 注意会有类型转换的影响，即+2 和2返回的类型可能不一样

[*] 表达式存在的目的是为了表达一个值的计算过程。

[*] 优先级和()只是表达了结合性，没有定义求值顺序;

[*] 只有&& || ?: , 定义了求值顺序

[*] ++a表达式的值是a的值加1，但是a的值什么时候自己更新到加1这个由序列点确定，
    同理a++的表达式的值是a的值，但是a什么时候更新也是序列点确定的，
    这种表达式叫做带有副作用的表达式，但是要分清表达式的值和副作用起作用的时候和
    表达式的值无关

[*] C 语言只保证副作用一定会发生，却不保证会何时发生。

[*] .和->左面可以是右值表达式

[*] 允许同类型的结构体和共用体变量互相赋值

[*] 数组和指针的区别，&和sizeof还有字符串数组初始化“”表示的就是数组本身，
    其余的像[]都是先求值为指向第一个元素的指针然后进行运算；函数名称除了&和
    sizeof 之外求值为指向本函数的指针；但是和数组不一样的是，
    数组不是变成一个数组指针（多维除外）而是hh第一个元素类型的指针，这个和函数不同；

[*] 运算符? :适用于短的表达式，这时它可以把4行的if-else程序变成1行。例如这样：
    max = (a < b) ? a : b;
    printf(“the list has %d item%s\n”, n, (n == 1) ? “” : “s”);
    但是它不应该成为条件语句的一般性替换；？：是表达式，if是语句，结果需要由两个
    操作数的类型决定，两个操作数分别进行普通一元转换，然后在进行转换成同一类型
    例如（3） ? 1∶2.
    不少人以为这个结果是1，但实际上结果为(double)1。这是因为在进行“?:”条件运算时，
    如果第二个操作数和第三个操作数类型不一致时，存在类型转换，
    这种转换就如同求表达式“1+2.”的值时所发生的转换一样。
    因此，“3?1:2.”的真正含义其实是“（3） ? (double)1 : 2.”。

[*] 条件表达式第一个参数必须加括号；

[*] 尽可能用sizeof(varname)代替sizeof(type)。
    使用sizeof(varname)是因为当变量类型改变时代码自动同步，
    有些情况下sizeof(type)或许有意义，还是要尽量避免，如果变量类型改变的话不能同步。
    SOMETYPE *p = OPENSSL_malloc(sizeof(*p) * num_of_elements);

[*] C 语言中，当表达式的值没有使用时，传统的做法是使用后置自增，特别是在for循环中，
    有些人觉得后置自增更加易懂，因为这很像自然语言，主语（i）在谓语动词（++）前。

[*] 在表达式中使用括号，使表达式的运算顺序更清晰。

[*] 避免表达式中的附加功能，不要编写太复杂的复合表达式;

[*] 条件判断表达式中禁止出现’=’;
    if ((*dst++ = *src++) != ‘\0’) {
    }

[*] 少用含有否定的表达式;
    反例:
    if (!(start > a) || !(start <= b))
    正例：
    if ((start <= a) || (start > b))

[*] 在条件判断表达式中，当整型变量与0 比较时，不可模仿布尔变量的风格，
    应当将整型变量用“==”或“!=”直接与0比较。
    正例：
    if (a == 0)
    if (a != 0)
    反例：
    // 会让人误解a是布尔变量
    if (!a)
    if (a)

[*] 不可将浮点变量用“==”或“!=”与任何数字比较。
    无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量
    用“==”或“!=”与数字比较，应该转化成“>=”或“<=”形式。
    正例：
    if ((fResult >= -EPSINON) && (fResult <= EPSINON))
    反例：
    if (fResult == 0.0)  // 隐含错误的比较
    其中EPSINON是允许的误差（即精度）

[*] 应当将指针变量用“==”或“!=”与NULL比较。
    说明：指针变量的零值是“空”（记为NULL），即使NULL的值与0相同，但是两者意义不同。
    正例：
    // p与NULL显式比较，强调p是指针变量
    if (p == NULL)
    if (p != NULL)
    反例：
    // 容易让人误解是整型变量
    if (p == 0)
    if (p != 0)
    或者
    // 容易让人误解p是布尔变量
        if (!p)
        if (p)

[*] 常量表达式可以用来做静态断言
    /* Force a compilation error if condition is true, but also produce a
   result (of value 0 and type size_t), so the expression can be used
   e.g. in a structure initializer (or where-ever else comma expressions
   aren't permitted). */
#define BUILD_BUG_ON_ZERO(e) (sizeof(struct { int:-!!(e); }))
#define BUILD_BUG_ON_NULL(e) ((void *)sizeof(struct { int:-!!(e); }))
   This is, in effect, a way to check whether the expression e can be evaluated to be 0, and if not, to fail the build.

The macro is somewhat misnamed; it should be something more like BUILD_BUG_OR_ZERO, rather than ...ON_ZERO. (There have been occasional discussions about whether this is a confusing name.)

You should read the expression like this:

sizeof(struct { int: -!!(e); }))
(e): Compute expression e.

!!(e): Logically negate twice: 0 if e == 0; otherwise 1.

-!!(e): Numerically negate: 0 if e == 0; otherwise -1.

struct{int: -!!(0);} --> struct{int: 0;}: If it was zero, then we declare a struct with an anonymous integer bitfield that has width zero. Everything is fine and we proceed as normal.

struct{int: -!!(1);} --> struct{int: -1;}: On the other hand, if it isn't zero, then it will be some negative number. Declaring any bitfield with negative width is a compilation error.

So we'll either wind up with a bitfield that has width 0 in a struct, which is fine, or a bitfield with negative width, which is a compilation error. Then we take sizeof that field, so we get a size_t with the appropriate width (which will be zero in the case where e is zero)

[*] What's the best way to suppress "unused parameter" warning in C code
I usually write a macro like this:

#define UNUSED(x) (void)(x)
You can use this macro for all your unused parameters. (Note that this works on any compiler.)

For example:

void f(int x) {
    UNUSED(x);
    ...
}

                    语句

[*] ‘;’不是c语言的语句分隔符，是某些语句的组成部分;

[*] ‘=’是一个运算符,有返回值;

[*] 表达式语句就是表达式加’;’构成,求值这个表达式,然后把最终的值扔掉;

[*] 复合语句语法上等价于单条语句，它可以出现在任何单条语句可以出现的位置；

[*] 一条语句只完成一个功能。

[*] 不要把多个语句放在一行里，除非你有什么东西要隐藏：
    if (condition) {do_this;}
    do_something_everytime;

[*] 不要在一行里放多个赋值语句。代码风格要超级简单。就是避免可能导致别人误读的
    表达式。

[*] 不可在for 循环体内修改循环变量，防止for 循环失去控制。

[*] do while语句和while语句仅使用一个条件。
说明：保持程序简洁。如果需要判断的条件较多，建议用临时布尔变量或者函数先计算是否满足条件

[*] 如果循环体内存在逻辑判断，并且循环次数很大，宜将逻辑判断移到循环体的外面。
    说明：下面两个示例中，反例比正例多执行了NUM -1次逻辑判断。并且由于前者总要进行
    逻辑判断，使得编译器不能对循环进行优化处理，降低了效率。如果NUM非常大，
    最好采用正例的写法，可以提高效率。
    const int NUM = 100000;
    if (is_true) {
        for (i = 0; i < NUM; i++) {
            do_something();
    }
    } else {
        for (i = 0; i < NUM; i++) {
            do_otherthing();
    }
    }
    反例:
    for (i = 0; i < NUM; i++) {
        if (is_true) {
            do_something();
        } else {
            do_otherthing();
    }

[*] switch的case和switch对齐,对于某个label有语句而且和相邻的label没有break需要
添加注释,如果没有语句则不需要添加注释;而且必须带default,且放在最后并且也带break;
    switch (suffix) {
    case 'G': /*不需要添加注释*/
    case 'g':
        mem <<= 30;
        break;
    case 'M':
    case 'm':
        mem <<= 20;
        break;
    case 'K':
    case 'k':
        mem <<= 10;
        /* fall through */
    default:
        break;
    }

                    stdlib

[*] 尽量使用memmove()代替memcpy()

[*] calloc()函数分配的空间有个重要的性质是这个空间中的内存单元都被按位初始化为
    0。应该注意的是，这并不一定意味着可以自动得到初值为0.0 的浮点数据以及初值
    为NULL 的指针

[*] 使用free()函数必须小心，不能多次释放同一块内存，否则是一种未定义行为


                    Scope rules in C

[*] c的名字作用域分为global和块级别的；全局的又分为文件级别的和程序级别的；

[*] 控制结构中的{} 也是引入一个scope，但是坚决禁止在控制结构中引入声明,除非是macro；

[*] 词法和语法分析称为编译器的前段，把程序的语义翻译成对应目标机的东西叫做
    编译器的后端；

[*] 寻址和对象的name不是一个层面上的东西，name说的是绑定关系，寻址或者地址说的是
    实现方式；所以c里面的指针作用就是动态建立name和对象的绑定关系；

[*] 语义分析和检查分为静态语义检查和动态语义检查；c就是输入静态检查比较弱，
    然后完全没有运行时的检查，完全为了效率原因；

[*] c里面的语句表达式完美，解决了表达式中不能是语句的问题；

[*] c对泛型的支持，通过typeof实现，一定注意命名规则问题，因为宏是破坏名字空间的，
    即使用红的地方都会根据用户的使用引入（拷贝）过来很多名字，可能是使用宏的
    上下文里面的名字重叠；所以宏不是什么好东西；

[*] 值和对象区别，值相当于立即数，对象需要一次动态的寻址才能获取到值，
    值-》对象-》指针间接引用，灵活性越来越高，但是效率越来越低；一个不用寻址，
    一个需要直接寻址，一个需要多次间接寻址；值一定也有类型的、从cpu角度考虑
    更合适，就是cpu拿到数据之后，放到寄存器里面，没有ram和他对应，值要么绑定到
    指令中，要么就是cpu在计算过程中生成的临时放在寄存器中的东西，反正不会在ram
    中，至少概念上是这样的；

[*] 所谓的静态类型指的是一个名字在同一个作用域呢只能绑定某一个类型的对象；
    变量的bind就是变量的name和某个类型的对象进行了绑定；

[*] 函数传参数都可以认为是动态的name和对象binding

[*] c的执行顺序：三个层面：第一个是c源码顺序；2是编译器生成之后的机器码顺序；
    3是机器的执行顺序；对于单核可以不考虑3，单核保证3和2的结果是一致的；但是1和2
    有可能不一样；多核并不保证编译器生成的机器指令顺序是一致的，需要使用手动使用
    内存屏障来显示控制；

[*] 一定要主要编译器优化的考虑；比如volatile的使用；因为编译器在优化的时候总是
    认为是单线程的；如果在两个指令之间没有写，那他就认为数据是一样的(这个和
    编译器优化的级别没有关系，即是否是按照objfile级别进行优化还是按照function进行
    优化，核心是编译器认为是单线程执行的，即只要在个单线程控制流之间有两个读，
    中间没有写，则就可以进行假设采用缓存中的值)，直接采用cache中或者register中的
    缓存值，volatile就是说有不可控制因素可能改变这个值，让编译器不要做这个假设
    进行优化；

[*] 两个volatile之间是保证顺序的，即源码顺序和机器码顺序是一致的；

[*] 一定要以实际的执行顺序考虑问题；

[*] Why the "volatile" type class should not be used
    ------------------------------------------------
    C programmers have often taken volatile to mean that the variable could be
    changed outside of the current thread of execution; as a result, they are
    sometimes tempted to use it in kernel code when shared data structures are
    being used.  In other words, they have been known to treat volatile types
    as a sort of easy atomic variable, which they are not.  The use of volatile in
    kernel code is almost never correct; this document describes why.

    The key point to understand with regard to volatile is that its purpose is
    to suppress optimization, which is almost never what one really wants to
    do.  In the kernel, one must protect shared data structures against
    unwanted concurrent access, which is very much a different task.  The
    process of protecting against unwanted concurrency will also avoid almost
    all optimization-related problems in a more efficient way.

    Like volatile, the kernel primitives which make concurrent access to data
    safe (spinlocks, mutexes, memory barriers, etc.) are designed to prevent
    unwanted optimization.  If they are being used properly, there will be no
    need to use volatile as well.  If volatile is still necessary, there is
    almost certainly a bug in the code somewhere.  In properly-written kernel
    code, volatile can only serve to slow things down.

    Consider a typical block of kernel code:

        spin_lock(&the_lock);
        do_something_on(&shared_data);
        do_something_else_with(&shared_data);
        spin_unlock(&the_lock);

    If all the code follows the locking rules, the value of shared_data cannot
    change unexpectedly while the_lock is held.  Any other code which might
    want to play with that data will be waiting on the lock.  The spinlock
    primitives act as memory barriers - they are explicitly written to do so -
    meaning that data accesses will not be optimized across them.  So the
    compiler might think it knows what will be in shared_data, but the
    spin_lock() call, since it acts as a memory barrier, will force it to
    forget anything it knows.  There will be no optimization problems with
    accesses to that data.

    If shared_data were declared volatile, the locking would still be
    necessary.  But the compiler would also be prevented from optimizing access
    to shared_data _within_ the critical section, when we know that nobody else
    can be working with it.  While the lock is held, shared_data is not
    volatile.  When dealing with shared data, proper locking makes volatile
    unnecessary - and potentially harmful.

    The volatile storage class was originally meant for memory-mapped I/O
    registers.  Within the kernel, register accesses, too, should be protected
    by locks, but one also does not want the compiler "optimizing" register
    accesses within a critical section.  But, within the kernel, I/O memory
    accesses are always done through accessor functions; accessing I/O memory
    directly through pointers is frowned upon and does not work on all
    architectures.  Those accessors are written to prevent unwanted
    optimization, so, once again, volatile is unnecessary.

    Another situation where one might be tempted to use volatile is
    when the processor is busy-waiting on the value of a variable.  The right
    way to perform a busy wait is:

        while (my_variable != what_i_want)
            cpu_relax();

    The cpu_relax() call can lower CPU power consumption or yield to a
    hyperthreaded twin processor; it also happens to serve as a compiler
    barrier, so, once again, volatile is unnecessary.  Of course, busy-
    waiting is generally an anti-social act to begin with.

    There are still a few rare situations where volatile makes sense in the
    kernel:

    - The above-mentioned accessor functions might use volatile on
        architectures where direct I/O memory access does work.  Essentially,
        each accessor call becomes a little critical section on its own and
        ensures that the access happens as expected by the programmer.

    - Inline assembly code which changes memory, but which has no other
        visible side effects, risks being deleted by GCC.  Adding the volatile
        keyword to asm statements will prevent this removal.

    - The jiffies variable is special in that it can have a different value
        every time it is referenced, but it can be read without any special
        locking.  So jiffies can be volatile, but the addition of other
        variables of this type is strongly frowned upon.  Jiffies is considered
        to be a "stupid legacy" issue (Linus's words) in this regard; fixing it
        would be more trouble than it is worth.

    - Pointers to data structures in coherent memory which might be modified
        by I/O devices can, sometimes, legitimately be volatile.  A ring buffer
        used by a network adapter, where that adapter changes pointers to
        indicate which descriptors have been processed, is an example of this
        type of situation.

    For most code, none of the above justifications for volatile apply.  As a
    result, the use of volatile is likely to be seen as a bug and will bring
    additional scrutiny to the code.  Developers who are tempted to use
    volatile should take a step back and think about what they are truly trying
    to accomplish.

    Patches to remove volatile variables are generally welcome - as long as
    they come with a justification which shows that the concurrency issues have
    been properly thought through.

      toools
    checkpatch.pl帮助信息
    位于Linux内核树scripts/
    可以自动修复代码中的问题
    如果使用 --fix-inplace 选项记得备份
    ./checkpatch.pl -h              # 查看帮助信息
    Usage: checkpatch.pl [OPTION]... [FILE]...
    Version: 0.32
    Options:
    --no-tree             run without a kernel tree
    --no-signoff          not check 'Signed-off-by' line
    --terse               one line per report
    -f, --file            treat FILE as regular file
    --fix                 may create horrible results
    --fix-inplace         may create horrible results

# 对当前目录下所有源代码检查风格
    find -name "*.[ch]" | xargs -n 1 ./checkpatch.pl --no-tree -f
# 对当前目录下所有源代码修正风格
    find -name "*.[ch]" | xargs -n 1 ./checkpatch.pl --no-tree -f \
    --fix-inplace
# 对所有补丁检查风格
    ./checkpatch.pl --no-tree *.patch
# 对所有补丁修正风格
    ./checkpatch.pl --no-tree --fix-inplace *.patch


head file Search Path

By default, the preprocessor looks for header files included by the quote form
of the directive #include "file" first relative to the directory of the current file,
and then in a preconfigured list of standard system directories.
For example, if /usr/include/sys/stat.h contains #include "types.h",
GCC looks for types.h first in /usr/include/sys, then in its usual search path.

For the angle-bracket form #include <file>, the preprocessor’s default behavior is
to look only in the standard system directories.
The exact search directory list depends on the target system,
how GCC is configured, and where it is installed.
You can find the default search directory list for your version of CPP by 
invoking it with the -v option. For example,
cpp -v /dev/null -o /dev/null

There are a number of command-line options you can use to add additional directories 
to the search path. The most commonly-used option is -Idir, which causes dir to be searched
after the current directory (for the quote form of the directive) and
ahead of the standard system directories.
You can specify multiple -I options on the command line, in which case the directories 
are searched in left-to-right order.

If you need separate control over the search paths for the quote and angle-bracket 
forms of the ‘#include’ directive, you can use the -iquote and/or -isystem options 
instead of -I. See Invocation, for a detailed description of these options, 
as well as others that are less generally useful.

If you specify other options on the command line, such as -I,
that affect where the preprocessor searches for header files,
the directory list printed by the -v option reflects the actual search path 
used by the preprocessor.

Note that you can also prevent the preprocessor from searching any of the 
default system header directories with the -nostdinc option. This is useful 
when you are compiling an operating system kernel or some other program that 
does not use the standard C library facilities, or the standard C library itself.

new skill: 
* += 符合运算符考虑方式和++ — 一样进行考虑；都是自***，前面是主语后面是宾语；例如，减去2，i增加2， i左移2比特，i和0xaa 与；
* 指针和数组的关系： 指针很多运算例如算数运算什么的，都是数组的index；不是一个简单整数，即使是diff p1 - p2 也是index；p1 - p2 = index;  p1 = p2 + index;所以是index； p +i  p 指向index0 的话，结果就是ith元素的地址；
*  数组index 大于等于0； 指针的这个index 可以是负整数； 即数组和指针只是有一部分交集而已；数组也有的地方是指针不具备的，比如sizeof 数组名什么的；指针这种操作都是线性地址空间；
*  指针也和struct union 有关系，都是offset方式进行访问；struct 本身也定义了一个线性地址空间；
*   Because pointers in BCPL and B are merely integer indices in the memory array, arithmetic on them is meaningful: if p is the address of a cell, then p+1 is the address of the next cell. 

*  typedef 只是是一个别名，编译器其实是知道什么类型的；typedef 和#define 有点像，但是由于是预处理器和编译器分别处理的，所以有区别； typedef char *String;   String p, lineptr[MAXLINES], alloc(int); 
*   对于编译器：等效于：char *p, *lineptr[MAXLINES], *alloc(int);
*    #define String  char*;   String p, lineptr[MAXLINES], alloc(int);  等效于  char *p, lineptr[MAXLINES], alloc(int); 
* macro： include  object-like  function-like    stringizing 参数， concatanation 参数；


*        ==      equal to (.EQ. to Fortraners)
*        !=      not equal to
*        >       greater than
*        <       less than
*        >=      greater than or equal to
*        <=      less than or equal to


 `&&' (AND), `||' (OR), and `!' (NOT).  

c， string const is refer to a conct char array；
Text is usually kept as an array of characters, as we did with line[ ] in the example above  
The symbol `->' means we're pointing at a member of a structure; `->' is only used in that context.  ptr is a pointer to the (base of) a structure that contains the structure member. 
 * refer to completely object，->refer to member of struct or union;   and this point, we learn   union is a special struct , every member is the address of union(In effect, a union is a structure in which all members have offset zero from the base, the structure is big enough to hold the "widest" member, and the alignment is appropriate for all of the types in the union. The same operations are permitted on unions as on structures: assignment to or copying as a unit, taking the address, and accessing a member. 
);


C has a goto statement and labels, so you can branch about the way you used to.  But most of the time goto's aren't needed.  (How many have we used up to this point?)  The code can almost always be more clearly expressed by for/while, if/else, and compound statements.
One use of goto's with some legitimacy is in a program which contains a long loop, where a while(1) would be too extended.  Then you might write
          mainloop:
               ...
               goto mainloop;
Another use is to implement a break out of more than one level of for or while.  goto's can only branch to labels within the same function.


x -= 10;
uses the assignment operator `-=‘ to decrement x by 10, and
       x &= 0177
forms the AND of x and 0177


C在它那类语言中的两个最具特征的思想是：数组和指针的关系，声明语法模拟表达式语法

C 另外一个特性：需要关注字符串和数组之间的关系：
C把串当作在管理上用标记终结的字符数组。  C treats strings as arrays of characters conventionally terminated by a marker 
   （） cast 运算符 ，必须使用括号的原因是c申明模仿是的表达式求值，所以不加括号 分不清是表达式还是声明；
     every statement ends with a semicolon；
     Syntactically, Pascal is much more ALGOL-like than C. English keywords are retained where C uses punctuation symbols – Pascal has and, or, and mod where C uses &&, ||, and % for example. However, C is actually more ALGOL-like than Pascal regarding (simple) declarations, retaining the type-name variable-name syntax. 

__attribute__ is not part of C, but is an extension in GCC that is used to convey special information to the compiler. 

Pascal programming language provides a data structure called the array, which can store a fixed-size sequential collection of elements of the same type

正确的赋值应该是使用 :=, equal to 使用=；
指针声明应该使用-> 而不是*；

Many people had observed that the problem with C's declarator syntax was that the declarator operator * ("pointer to") is prefix, whereas the declarator operators [] ("array of") and () ("function return- ing") are postfix. This 

c declaration mimic use（expression）；

Similarly, I considered the possibility of introducing a linear notation for declarators. The C trick of having the declaration of a name mimic its use leads to declarations that are hard to read and write, and maximizes the opportunity for humans and pro- grams to confuse declarations and expressions. Many people had observed that the problem with C's declarator syntax was that the declarator operator * ("pointer to") is prefix, whereas the declarator operators [] ("array of") and () ("function return- ing") are postfix. This forces people to use parentheses to disambiguate cases such as: 
/* C style: */ int* v[10]; /* array of pointers to ints */ int (*p) [10]; /* pointer to array of ints */ 
Together with Doug McIlroy, Andrew Koenig, Jonathan Shopiro, and others I consid- ered introducing postfix "pointer to" operator -> as an alternative to the prefix *: 
// radical alternative: v: [10]->int ; // array of pointers to ints 
p: ->[10]int; 
int v[10]->; int p->[10]; 
// pointer to array of ints 
// less radical alternative: // array of pointers to ints 
// pointer to array of ints 
The less radical alternative has the advantage of allowing the postfix -> declarator to coexist with the prefix * declarator during a transition period. After a transition period the * declarator and the redundant parentheses could have been removed from the language. A noticeable benefit of this scheme is that parentheses are only needed to express "function" so that an opportunity for confusion and grammar subtleties could be removed (see also [Sethi, 1981]). Having all declarator operators postfix would ensure that declarations can be read from left to right.  Forexample: 
int f(char)->[10]->(double)->; 
meaning a function f returning a pointer to an array of pointers to functions returning a pointer to i n t . Try to write that in straight C/C++! Unfortunately, I fumbled the idea and didn't ever deliver a complete implementation. Instead, people build up complicated types incrementally using typedef: 
typedef int* DtoI(double); // function taking a double and // returning a pointer to int 
typedef DtoI* V10[10]; // array of 10 pointers to Dtol V10* f(char); // f takes a char and returns 
// a pointer to V10 
My eventual rationale for leaving things as they were was that any new syntax would (temporarily at least) add complexity to a known mess. Also, even though the old style is a boon to teachers of trivia and to people who want to ridicule C, it is not a significant problem for C programmers. In this case, I'm not sure if I did the right thing, though. The agony to me and other C++ implementers, documenters, and tool builders caused by the perversities of syntax has been significant. Users can - and do - of course insulate themselves from such problems by writing in a small and easily understood subset of the C/C++ declaration syntax (§7.2). 

Typedef: Alternative name for a type
